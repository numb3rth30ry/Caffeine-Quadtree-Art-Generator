import {
    type ReactNode,
    type PropsWithChildren,
    createContext,
    createElement,
    useCallback,
    useContext,
    useEffect,
    useMemo,
    useState
} from 'react';
import { AuthClient, type AuthClientCreateOptions, type AuthClientLoginOptions } from '@dfinity/auth-client';
import type { Identity } from '@dfinity/agent';
import { DelegationIdentity, isDelegationValid } from '@dfinity/identity';

export type Status = 'initializing' | 'idle' | 'logging-in' | 'success' | 'loginError';

export type InternetIdentityContext = {
    /** The identity is available after successfully loading the identity from local storage
     * or completing the login process. */
    identity?: Identity;

    /** Connect to Internet Identity to login the user. */
    login: () => void;

    /** Clears the identity from the state and local storage. Effectively "logs the user out". */
    clear: () => void;

    /** The loginStatus of the login process. Note: The login loginStatus is not affected when a stored
     * identity is loaded on mount. */
    loginStatus: Status;

    /** `loginStatus === "initializing"` */
    isInitializing: boolean;

    /** `loginStatus === "idle"` */
    isLoginIdle: boolean;

    /** `loginStatus === "logging-in"` */
    isLoggingIn: boolean;

    /** `loginStatus === "success"` */
    isLoginSuccess: boolean;

    /** `loginStatus === "loginError"` */
    isLoginError: boolean;

    loginError?: Error;
};

const ONE_HOUR_IN_NANOSECONDS = BigInt(3_600_000_000_000);
const DEFAULT_IDENTITY_PROVIDER = process.env.II_URL;

type ProviderValue = InternetIdentityContext;
const InternetIdentityReactContext = createContext<ProviderValue | undefined>(undefined);

/**
 * Create the auth client with default options or options provided by the user.
 */
async function createAuthClient(createOptions?: AuthClientCreateOptions): Promise<AuthClient> {
    const options: AuthClientCreateOptions = {
        idleOptions: {
            // Default behaviour of this hook is not to logout and reload window on identity expiration
            disableDefaultIdleCallback: true,
            disableIdle: true,
            ...createOptions?.idleOptions
        },
        ...createOptions
    };
    const authClient = await AuthClient.create(options);
    return authClient;
}

/**
 * Helper function to set loginError state.
 */
function assertProviderPresent(context: ProviderValue | undefined): asserts context is ProviderValue {
    if (!context) {
        throw new Error('InternetIdentityProvider is not present. Wrap your component tree with it.');
    }
}

/**
 * Hook to access the internet identity as well as loginStatus along with
 * login and clear functions.
 */
export const useInternetIdentity = (): InternetIdentityContext => {
    const context = useContext(InternetIdentityReactContext);
    assertProviderPresent(context);
    return context;
};

/**
 * The InternetIdentityProvider component makes the saved identity available
 * after page reloads. It also allows you to configure default options
 * for AuthClient and login.
 *
 *
 * @example
 * ```tsx
 * <InternetIdentityProvider>
 *   <App />
 * </InternetIdentityProvider>
 * ```
 */
export function InternetIdentityProvider({
    children,
    createOptions
}: PropsWithChildren<{
    /** The child components that the InternetIdentityProvider will wrap. This allows any child
     * component to access the authentication context provided by the InternetIdentityProvider. */
    children: ReactNode;

    /** Options for creating the {@link AuthClient}. See AuthClient documentation for list of options
     *
     * defaults to disabling the AuthClient idle handling (clearing identities
     * from store and reloading the window on identity expiry). If that behaviour is preferred, set these settings:
     *
     * ```
     * const options = {
     *   idleOptions: {
     *     disableDefaultIdleCallback: false,
     *     disableIdle: false,
     *   },
     * }
     * ```
     */
    createOptions?: AuthClientCreateOptions;
}>) {
    const [authClient, setAuthClient] = useState<AuthClient | undefined>(undefined);
    const [identity, setIdentity] = useState<Identity | undefined>(undefined);
    const [loginStatus, setStatus] = useState<Status>('initializing');
    const [loginError, setError] = useState<Error | undefined>(undefined);

    const setErrorMessage = useCallback((message: string) => {
        setStatus('loginError');
        setError(new Error(message));
    }, []);

    const handleLoginSuccess = useCallback(() => {
        const latestIdentity = authClient?.getIdentity();
        if (!latestIdentity) {
            setErrorMessage('Identity not found after successful login');
            return;
        }
        setIdentity(latestIdentity);
        setStatus('success');
    }, [authClient, setErrorMessage]);

    const handleLoginError = useCallback(
        (maybeError?: string) => {
            setErrorMessage(maybeError ?? 'Login failed');
        },
        [setErrorMessage]
    );

    const login = useCallback(() => {
        if (!authClient) {
            setErrorMessage(
                'AuthClient is not initialized yet, make sure to call `login` on user interaction e.g. click.'
            );
            return;
        }

        const currentIdentity = authClient.getIdentity();
        if (
            !currentIdentity.getPrincipal().isAnonymous() &&
            currentIdentity instanceof DelegationIdentity &&
            isDelegationValid(currentIdentity.getDelegation())
        ) {
            setErrorMessage('User is already authenticated');
            return;
        }

        const options: AuthClientLoginOptions = {
            identityProvider: DEFAULT_IDENTITY_PROVIDER,
            onSuccess: handleLoginSuccess,
            onError: handleLoginError,
            maxTimeToLive: ONE_HOUR_IN_NANOSECONDS
        };

        setStatus('logging-in');
        void authClient.login(options);
    }, [authClient, handleLoginError, handleLoginSuccess, setErrorMessage]);

    const clear = useCallback(() => {
        if (!authClient) {
            setErrorMessage('Auth client not initialized');
            return;
        }

        void authClient
            .logout()
            .then(() => {
                setIdentity(undefined);
                setStatus('idle');
                setError(undefined);
            })
            .catch((unknownError: unknown) => {
                setStatus('loginError');
                setError(unknownError instanceof Error ? unknownError : new Error('Logout failed'));
            });
    }, [authClient, setErrorMessage]);

    useEffect(() => {
        let cancelled = false;
        void (async () => {
            try {
                setStatus('initializing');
                let existingClient = authClient;
                if (!existingClient) {
                    existingClient = await createAuthClient(createOptions);
                    if (cancelled) return;
                    setAuthClient(existingClient);
                }
                const isAuthenticated = await existingClient.isAuthenticated();
                if (cancelled) return;
                if (isAuthenticated) {
                    const loadedIdentity = existingClient.getIdentity();
                    setIdentity(loadedIdentity);
                }
            } catch (unknownError) {
                setStatus('loginError');
                setError(unknownError instanceof Error ? unknownError : new Error('Initialization failed'));
            } finally {
                if (!cancelled) setStatus('idle');
            }
        })();
        return () => {
            cancelled = true;
        };
    }, [createOptions]);

    const value = useMemo<ProviderValue>(
        () => ({
            identity,
            login,
            clear,
            loginStatus,
            isInitializing: loginStatus === 'initializing',
            isLoginIdle: loginStatus === 'idle',
            isLoggingIn: loginStatus === 'logging-in',
            isLoginSuccess: loginStatus === 'success',
            isLoginError: loginStatus === 'loginError',
            loginError
        }),
        [identity, login, clear, loginStatus, loginError]
    );

    return createElement(InternetIdentityReactContext.Provider, { value, children });
}
